---
title: React Fiber
order: 2
---

# React Fiber

## 1. 为什么要诞生 Fiber 架构

`React16+` 用的新架构，至于为什么会出现 Fiber，那就首先从 react 的理念开始说起。

### 1.1 React 的理念

React 的理念是什么呢？直接从[官网](https://zh-hans.reactjs.org/docs/thinking-in-react.html)搬过来的概念是这样子说的：

> 我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。它在 Facebook 和 Instagram 上表现优秀。
>
> 关键字：**快速响应**

### 1.2 制约快速响应的因素

既然 `react` 的核心理念是快速响应，那么正常开发中一般会有哪些制约快速响应的因素呢。从个人角度出发的认知大概有两种：

- **`js` 引擎和 `ui` 渲染引擎互斥**：在进行 `js` 大量数据、高度复杂计算时，出现页面 ui 渲染的卡顿
- **请求延时**：请求接口因为数据需要请求一段时间才能返回所导致的页面操作空档期（就是需要获取到数据之后才能进行下一步）

`React` 为了解决这些痛点，于是推出来了 **Fiber 架构** 来解决这个问题。

---

## 2. 计算时的渲染卡顿

### 2.1 卡顿示例

##### 2.1.1 大量数据计算

假如我们在页面里面写了这么一个组件：

```js
function Demo() {
  return new Array(5000).map((_, i) => {
    <div>{i}</div>;
  });
}
```

按照主流浏览器刷新率 **60** 帧计算，一帧就是 `16.7ms`。所以浏览器需要在 `16.7ms` 中完成以下三件事：

> `js 计算 --> 样式计算 --> 样式布局`
>
> 但是因为 **js 线程和 GUI 线程互斥**，计算时，浏览器不能进行布局渲染，所以当计算时间超出 `16.7ms` 时，浏览器就不能在这一帧里进行样式布局和绘制

如上，`Demo` 中绘制了 `5000` 个 `dom`，所用时间大幅度超过了 `16.7ms`，页面就会掉帧，那么在这些 `dom` 渲染时，用户会有感知的卡顿

所以 `React` 就给出了解决办法：

- **在浏览器的每一帧时间中，预留一些时间给 js 线程，`React`利用这部分时间更新组件**（_React 预留的时间是 5ms_）

- 当预留的时间不够的时候，React 会将线程控制权还给浏览器，使其有时间去渲染 `UI`。

##### 2.1.2 用户交互

指当用户客户端性能差时，进行输入操作，输入卡顿：

- `React` 旧版，更新过程是同步的，每新输入一个字符，都要等上一次渲染完成
- 每次渲染调用各组件（_假设 100+组件_）生命周期，产生大量 **I/O**，导致键盘输入延迟
  - 此时主线程被 `React` 占用，结果是用户敲了按键看不到反应，更新后，一下子出现在输入框

<Alert type="info">**JS 单线程** 的特点：就是每个同步任务不能耗时太长，不然会使程序对输入无法响应</Alert>

### 2.2 时间切片

**时间切片**：说白了，以切片的形式 **分解任务**，然后按照 **优先级不同**，进行 **异步实现**

> 实现关键：将 **同步的更新** 变成 **可中断的异步更新**。

- 长任务拆分到每一帧，执行小任务时，`js` 线程大概只占用 `5ms`
- 浏览器用剩余时间去执行样式布局和样式绘制，从而减少了掉帧的可能性。

---

## 3. React Fiber

### 3.1 为啥叫 Fiber

类比`python`，进程、线程后，还有协程，差不多一个意思，只是叫法不同罢了

### 3.2 影响

在 `React Fiber` 中，一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会**完全作废，然后等待机会重头再来**

因此，更新过程被分为 **两个阶段(Phase)**：

1. `Reconciliation Phase（协调阶段）`

   - 找出需要更新那些 `DOM`，那个阶段可被打断

2. `Commit Phase（提交阶段）`

   - 一口气更新完 `DOM`，原子操作，绝对不会被打断

   > 如上则按照 `render` 前后生命周期划分，故 `render` 前的生命周期，会失败，会多次调用
