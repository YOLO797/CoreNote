---
title: 前端发展史
order: 1
group:
  title: 前端发展史
  order: 1
---

# 前端发展史

## 1. 静态页面阶段

互联网发展的早期，网站的前后端开发是一体的，即前端代码是后端代码的一部分（_`Jinjia`模板_），此时后端渲染

1. 后端收到浏览器的请求
2. 渲染生成静态页面
3. 发送到浏览器

> 那时的前端页面都是静态的，所有前端代码和前端数据都是后端生成的，前端只是纯粹的展示功能，脚本的作用只是增加一些特殊效果，比如那时很流行用脚本控制页面上飞来飞去的广告

那时的网站开发，采用的是后端 **MVC** 模式

- **Model**（模型层）：提供/保存数据

- **Controller**（控制层）：数据处理，实现业务逻辑

- **View**（视图层）：展示数据，提供用户界面

前端只是后端 **MVC** 的 **V**

## 2. AJAX 阶段

`2004` 年，**AJAX** 技术诞生，改变了前端开发。`Gmail` 和 `Google地图` 这种革命性的产品出现，使开发者发现，前端的作用不仅仅是展示页面，还能管理数据并与用户互动

- **AJAX** 技术：脚本独立向服务器请求数据，拿到数据以后，进行处理并更新网页
- 后端只是负责提供数据，其他事情都由前端 `JavaScript` 处理
- 实现了从 **获取数据** -> **处理数据** -> **展示数据** 的完整业务逻辑

> 就是从这个阶段开始，前端脚本开始变得复杂，不再仅仅是一些玩具性的功能

## 3. 前端 MVC 阶段

前端代码有了读写数据、处理数据、生成视图等功能，因此迫切需要辅助工具，方便开发者组织代码。这导致了前端 **MVC** 框架的诞生

`2010`年，第一个前端 **MVC** 框架 `Backbone.js` 诞生，它基本上是把 **MVC** 模式搬到了前端，但是只有 **M** （读写数据）和 **V**（展示数据），没有 **C**（处理数据）。因为，`Backbone` 认为前端 **Controller** 与后端不同，不需要、也不应该处理业务逻辑，只需要处理 **UI** 逻辑，响应用户的一举一动。所以，数据处理都放在后端，前端只用事件响应处理 **UI** 逻辑（用户操作）

后来，更多的前端 **MVC** 框架出现，另一些框架提出 **MVVM** 模式，用 **View Model** 代替 **Controller**，**MVVM** 模式也将前端应用分成三个部分

- **Model**：读写数据

- **View**：展示数据

- **View-Model**：数据处理

> **View Model** 是简化的 **Controller**，所有的数据逻辑都放在这个部分，它的唯一作用就是为 **View** 提供处理好的数据，不含其他逻辑。也就是说，**Model** 拿到数据以后，**View Model** 将数据处理成视图层（_View_）需要的格式，在视图层展示出来。

这个模型的特点是 **View** 绑定 **View Model**，如果 **View Model** 的数据变了，**View**（视图层）也跟着变了；反之亦然，如果用户在视图层修改了数据，也立刻反映在 **View Model**，整个过程完全不需要手工处理。

## 4. SPA 阶段

前端可以做到读写数据、切换视图、用户交互，这意味着，网页其实是一个应用程序，而不是信息的纯展示。这种单张网页的应用程序称为 **SPA**（_`single-page application`_）

- 在单页面（_`single page`_）上，模拟多页面应用程序（_`application`_）的效果
- 用户的浏览器只需将网页载入 **1** 次，剩下所有操作都可在这张页面上完成
- 响应迅速、根据路由切换虚拟页面（_非打开新页面_）

`2010`年后， **SPA** 的兴起，前端工程师从（_切模板_），变为开发 **前端应用**，最流行的前端框架 **Vue**、**React** 、**Angular** 等，都属于 **SPA** 开发框架

## 5. Serverless、XaaS、低代码

随着 **Docker**、**k8s** 诞生，从 **AWS** 演变来的各种云概念、新概念大行其道，`IaaS`、`PaaS`、`SaaS`、`FaaS`、`BtaaS` 和 `Serverless` 与随之而来的各种云平台、云服务，再加上 **NodeJS** 不断完善，前端全栈的开发模式、低代码平台等开始流行

**Web** 开发对于 **提升用户体验（UX）** 和 **开发者体验（DX）** 作为核心目越来越卷，有了如下问题需要解决

- 前端工具的繁杂缺少整合，漫长的 `webpack` `dev/build` 时间

- 交互繁琐 `axios`、`fetch` 要处理各种状态

- **SPA** 的首页加载时间、白屏问题

- 对爬虫等搜索引擎的 **SEO** 需求

因此诞生了配套 **Vue** 、**React** 与 **NodeJS** 的 **Next.js** 、**Nuxt.js** 、**Remix.js** 等已前端为首的全栈框架

##### 优势在于

- 前后端一体化的交互，常用 **GraphQL** 等和 **nodejs** 服务器进行数据交互
- 适配云原生，如 **Faas** + **BFF**
- 使用 **nodejs** 作为后端渲染，巨快（_50ms_），无 `loading`、骨架屏、白屏问题
- [渐进化（PWA）](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps)，虽然又退回到后端渲染，但可必要时才使用服务端渲染

### 6. 未来趋势

- 云原生时代下，以及**边缘计算**逐渐完善，**Web** 应用（**Node.js**、**Rust**、**Golang** 等）可以部署到 **CDN** 上（例如 [Cloudflare Workers](https://workers.cloudflare.com/)）
- **前后端一体**，社区现在倾向于将前后端放一起，模糊界限，有点像 **BFF** + 前端，让前端开发承担更多的开发责任，做更多的事。这样看 **FaaS** 不仅限于提供 **API**，同样可以**渲染出一个服务端组件**（如 [React Server Components](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html)）
- **更重视 UX**，开发者体验得到了更多重视，比如强类型、启动时间、错误信息、编译器检查（[rustc](https://doc.rust-lang.org/rustc/what-is-rustc.html)）等
