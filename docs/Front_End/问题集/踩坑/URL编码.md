---
title: URL编码
order: 1
group:
  title: 踩坑合集
  order: 51
---

# URL 编码

<Alert type="info">**URL** 特殊字符和 **JS** 编码解码方法</Alert>

## 1. 简介

[URL](https://blog.csdn.net/pcyph/article/details/45010609) 编码也称作百分号编码 `Percent-encoding`，是对我们在 `HTTP` 请求中的 **URL** 实行的编码机制

> `URL` 中有很多字符是有特殊意义的，比如 `?，&，=` 等， 不对特殊字符转义，就会错误解析，JS 中提供以下方法:

- `encodeURI`
- `decodeURI`
- `encodeURIComponent`
- `decodeURIComponent`

## 2. URL 编码与字符

编码方式简单，使用 `%` 百分号加上两位的字符 `0123456789ABCDEF` ，代表一个字节的十六进制形式

- 在 **US-ASCII** 中：`a -> 0x61`
- **URL**中：`a -> %61`

> 在地址栏上输入 `https://www.google.com/search?q=abc` 等同于 在 `Google` 上搜索 `abc`

#### 2.1 浏览器转义

若前端实现一个 **Linux** 映射的 目录组件，并想根据 **URL** 来解析，那么必不可少需要一些特殊字符的转义，否则浏览器无法解析出期望结果，当然包含中文也会造成问题（根据浏览器字符集不同而定）

> **比如**：
> 空格 -> `20%` 空格这种特殊字符会被转义为 20%

#### 2.2 字符

**RFC3986** 文档规定，**URL** 中只允许包含

- 英文字母 `（a-zA-Z）`
- 数字 `（0-9）`
- `-\_.~` 这四个特殊字符
- 以及所有保留字符

###### 保留字符

> `! \* ' ( ) ; : @ & = + $ , / ? # [ ]`
>
> **如：**
>
> - 冒号 `:` 用于分隔协议和主机
> - `/` 用于分隔 主机和路径
> - `?` 用于分隔路径和查询参数等

###### 不安全字符

- 空格
  - 在传输、排版、文本处理程序在处理 **URL** 的过程，可能引入无关紧要的空格，或将有意义的空格给去掉
- 引号 `""` 以及 `<>`

  - 引号和尖括号通常用于在普通文本中起到分隔 Url 的作用

- `#`
  - 通常用于表示书签或者锚点
- `%`
  - 百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码
- `{}|\^[]`~`
  - 某一些网关或者传输代理会篡改这些字符

#### 2.3 对非字符进行编码

当非字符在 **URL** 中，浏览器会默认将字符串编码为浏览器识别的合法 **URL** 字符

**JS** 中提供了方法对 **URL** 进行编码，将不安全不合法的 URL 字符转换为合法的 URL 字符

- `encodeURI`（_82 个_）
  - 安全字符为: `!#$&'()*+,/:;=?@-._~0-9a-zA-Z`
- `encodeURIComponent`（_71 个_）
  - 安全字符为: `!'()*-._~0-9a-zA-Z`

**注意**:

- `encodeURI` 和 `encodeURIComponent` 是使用 **UTF-8** 对非 **ASCII** 字符进行编码，然后再进行百分号编码

- 很多 `HTTP` 监视工具或者浏览器地址栏等在显示 **URL** 的时候会自动进行一次解码（使用 **UTF-8** 字符集）

这就是为什么当你在 **Firefox** 中访问 **Google** 搜索中文的时候，地址栏显示的 **URL** 包含中文的缘故

## 3. linux 文件名映射 URL 路由的解决办法

#### 3.1 环境

由于前端使用 **URL** 去映射 **Linux** 文件系统，当创建一个名称带有转义字符 `%` 的文件时，通过 `decodeURIComponent` 解析会解析失败

创建名包含 `%` 的文件

| 文件名 |             转义             |                          结果                          |
| :----: | :--------------------------: | :----------------------------------------------------: |
|  `%`   |  `decodeURIComponent("%")`   |             读取不到 `%` 后续内容解析失败              |
| `%20`  | `decodeURIComponent("%20")`  | 解析成了 `" "` 空格，但后端没有名为 `" "` 的文件，报错 |
| `%%20` | `decodeURIComponent("%%20")` |                 连续解析 `%` 解析失败                  |

#### 3.2 解决办法

由于使用路由监听，`watch` 监听变化的 **URL** 就会去使用 `decodeURIComponent` 解析新路由

- 因此需要在 `watch` 监听前（_即执行点击事件跳转前_）就将路由包含 `%` 的转义 为能正常解析的 `%25` 这个 **URL** 码

  ```js
  url_str.replace(/%/g, '%25');
  ```

- 再进行 `push router` 操作

- 当 `watch` 监听到，或 `URL` 重新请求时，则会将带有 `%25` 的路由获取
- 通过 `decodeURIComponent` 去转义为对应的 `%` 再向后端发起请求即可

**如：**

- 再次创建名称包含 `%` 的文件并点击跳转

  | 文件名      | URL 转义（跳转前） |
  | :---------- | :----------------- |
  | `%20%25%33` | `%2520%2525%2533`  |
  | `%%`        | `%25%25`           |

  > **注意**：含有待转义字符的文件名，无需跳转解码

- 带空格

  | 文件名 | URL 转义 |
  | ------ | -------- |
  | `1 2`  | `1%202`  |

  - 直接获取到 `1 2` 文件名
  - `watch` 监听时获取的 **URL** 路由自然会被编码成 `1%202`
  - 然后发送请求前再 `decodeURIComponent` 解码为原文件名即可
